---
title: "md and themed html documents"
subtitle: Subtitle
author: "Your name"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: '3'
    theme: united
    keep_md: true
---

```{r setup, include=FALSE}
# This chunk named setup will run before any other code (https://goo.gl/BeM2Uu)
set.seed(1014)
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  # Figures (http://r4ds.had.co.nz/)
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,
  fig.show = "hold"
)
```

```{r utils}
commas <- function(...) {
  paste0(..., collapse = ", ")
}

vv <- function(vft) {
  vft %>% 
  dplyr::select(
    PlotName, PlotCensusNumber, Tag, matches("status"), dplyr::everything()
  ) %>% 
  dplyr::arrange(PlotName, PlotCensusNumber, Tag)
}
```

Packages.

TODO: Declare pkg with `::`

```{r packages}
set.seed(1)

library(dplyr)
library(tidyr)
library(tidyverse)
library(lubridate)
library(here)
library(fs)
library(fgeo.base)
library(fgeo.tool)
```

# Task

> Cocoli should have the exact same number of censuses, but Sherman will have
one more census.

-- Suzanne

* Pick stems 1 cm and over (at 1.3 m)

> All trees at least 1 cm diameter at breast height were censused in three sites in Panama. 

-- [Condit et al.](https://dash.ucdavis.edu/stash/dataset/doi:10.15146/R3MM4V)

* Determine year as average or median year by census/plotcensusnumber

> In the datasets, you should look at the "plotcensusnumber" or "censusid"
instead of the years. Some censuses may take more than one year .... The years in the publications refer to the average or the median year.  

-- Suzanne

* Calculate count (abundance) and basal area by site (BCI, Cocoli, Sherman), species, family, year; and spread by year

E.g. https://forestgeo.si.edu/bci-abundance-all-tree-species-50-ha-plot-1982-2005-saplings-and-trees

Example 1

![](https://i.imgur.com/HxCGK05.png)

[Example 2](https://dash.ucdavis.edu/stash/dataset/doi:10.15146/R3MM4V)

```{r, message=FALSE}
path <- here("inst/issues/59_abund_tables/condit_et_al")
sites <- path %>% 
  dir_ls() %>% 
  map(readr::read_delim, "\t") %>% 
  set_names(path_file(dir_ls(path)))
sites
```

```{r}
sites %>% 
  map(select, -Latin, -Family, - Authority) %>% 
  map(names)
```

* Focus on alive trees. 

    * TODO: Should I pick status alive only or exclude status dead? For now, I'll conservatively exclude status dead. I could make this a parameter of the function to produce the tables.

> The three accompanying tables give the population size of living individuals of all species in every census at the three sites. 

-- [Condit et al.](https://dash.ucdavis.edu/stash/dataset/doi:10.15146/R3MM4V)

> Individuals with multiple stems from one root base were counted as single trees. 

-- [Condit et al.](https://dash.ucdavis.edu/stash/dataset/doi:10.15146/R3MM4V)


* TODO: What does this mean? I don't seem to need to standardize by area at all. What am I missing?

> To standardize a density per unit area, each count must be divided by the size of the plot: 50 ha at Barro Colorado, 4 ha at Cocoli, and 5.96 ha at Sherman.

-- [Condit et al.](https://dash.ucdavis.edu/stash/dataset/doi:10.15146/R3MM4V)

# Code

Example vft with data from multiple sites.

```{r}
path_base <- "../fgeo.data/inst/private/data-raw-private"
path_bci <- here::here(fs::path(path_base, "ViewFullTable_bci.csv"))
vft_bci <- fgeo.tool::read_vft(path_bci)
path_sc <- here::here(fs::path(path_base, "ViewFullTable_sherman_cocoli.csv"))
vft_sc <- fgeo.tool::read_vft(path_sc)
vft <- bind_rows(vft_bci, vft_sc)
```

## Inputs


```{r}
# @param vft A dataframe; particularly a ForestGEO viewFullTable.
vft
# @param status String giving possible values of `Status`.
valid_status <- c("dead", "alive", "broken below", "missing")

# @inheritParams fgeo.tool::filter_status
.status <- "dead"
exclude <- TRUE
```

Pick the `PlotName` you want. Defaults to use the fist census in alphabetical order.

```{r}
plot_nm <- sort(unique(vft$PlotName))
if (length(plot_nm) > 1) {
  warning(
    "Detected more than one `PlotName`: (", commas(plot_nm), ")\n",
    "* Using ", plot_nm[[1]],
    call. = FALSE
  )
}
vft_one <- vft %>% filter(PlotName == plot_nm[[1]])
```

TODO: Replace with full size data. Here creating a small subset to explore what needs to be done quickly.

```{r}
vft_pick <- vft_one %>% sample_n(10000)
vft_pick
```

# Pick useful data.

Check for inconsistent statuses.

```{r}
warn_if_bad_status <- function(status_col, status_arg) {
  if (!identical_status_levels(status_col, status_arg)) {
    warning(
      "Unique values of column `Status` and argument `valid_status` ", 
      "must match:\n",
      "* Status col: ", commas(sort(unique(status_arg))), ".\n",
      "* valid_status arg: ", commas(sort(unique(status_col))), ".",
      call. = FALSE
    )
  }
  invisible(status_col)
}

identical_status_levels <- function(status_col, status_arg) {
  identical(sort(unique(status_col)), sort(unique(status_arg)))
}



warn_if_bad_status(vft_pick$Status, valid_status)
```

Fix wrong status automatically or die trying.

```{r}
fix_status_if_bad_or_err <- function(vft, status_arg) {
  if (!identical_status_levels(vft$Status, status_arg)) {
    message("Fixing status automatically.")
    vft <- fix_bad_status(vft, vft$Status, status_arg)
    
    tryCatch(
      testthat::expect_silent(warn_if_bad_status(vft$Status, status_arg)),
      error = function(cond) {
        stop("Tried but failed to fix status automatically.", call. = FALSE)
      },
      warning = function(cond) "Failed to fix status automatically."
    )
  }
  invisible(vft)
}

fix_bad_status <- function(vft, status_col, status_arg) {
  vft$Status <- sub("^.*dead.*$", "dead", vft$Status)
  vft$Status <- sub("^.*alive.*$", "alive", vft$Status)
  vft
}



vft_pick <- fix_status_if_bad_or_err(vft_pick, valid_status)
```

## Tree status

Determine the status of each tree based on the status of its (multiple) stem(s).

```{r}
stts_tree <- vft_pick %>% 
  group_by(PlotCensusNumber) %>% 
  fgeo.tool::add_status_tree(status_a = "alive", status_d = "dead") %>% 
  ungroup()



# TODO: Remove
stts_tree %>% vv()
```

* If any, view cases of multi-stem trees where `Status` and `status_tree` are different.

```{r}
# TODO: Remove
stts_tree %>% 
  filter(Status != status_tree) %>% 
  group_by(PlotName, PlotCensusNumber) %>% 
  add_count(Tag) %>% 
  arrange(PlotName, PlotCensusNumber, Tag, Status, status_tree) %>% 
  filter(n > 1) %>%
  ungroup() %>% 
  select(matches("status"), Tag, matches("plot"), DBH) %>% 
  print(n = 50)
```

* View example of alive tree with missing DBH.

```{r}
# TODO: Remove
stts_tree %>% 
  filter(Tag == "021245") %>% 
  select(matches("status"), Tag, matches("plot"), DBH) %>% 
  arrange(PlotName, PlotCensusNumber, Tag, Status, status_tree)
```

* Exclude all rows where `DBH = NA`.

The example above shows that some alive trees may have missing DBH. I exclude all rows where `DBH = NA` because missing values can't be used for calculating basal area; and althought those rows can be used to count abundance, they are better excluded from abundance tables for consistency with basal area tables.

```{r}
not_na_dbh <- dplyr::filter(stts_tree, !is.na(DBH))
# TODO: Remove
not_na_dbh
```

* Exclude all rows where status_tree == status_d

```{r}
not_dead <- fgeo.tool::filter_status(
  not_na_dbh, wood = "tree", .status = .status, exclude = exclude
)
# TODO: Remove
not_dead %>% vv()
```

* Ignore rows where `ExactDate == NA` if any.

```{r missing_dates}
ignore_if_missing_dates <- function(x) {
  missing_dates <- is.na(x$ExactDate)
  if (any(missing_dates)) {
    warning("Detected and ignoring missing dates.")
  }
  x <- x[!missing_dates, , drop = FALSE]
  invisible(x)
}



not_na_dates <- ignore_if_missing_dates(not_dead)
```

* Calculate year as a round average of `ExactDate` by `PlotCensusNumber`.

```{r}
years <- not_na_dates %>% 
  group_by(PlotCensusNumber) %>% 
  summarise(year = round(mean(year(ExactDate), na.rm = TRUE))) %>% 
  unique() %>% 
  arrange(PlotCensusNumber) %>% 
  ungroup()
with_year <- left_join(not_na_dates, years, by = "PlotCensusNumber") %>% 
  arrange(year)
```

```{r}
with_year <- dplyr::mutate(with_year, species = paste(Genus, SpeciesName))
```

Abundance count.

```{r}
abundance <- with_year %>% 
  dplyr::count(species, Family, year) %>% 
  tidyr::spread(year, n, fill = 0) %>% 
  arrange(species, Family)
abundance
```

Basal area.

```{r}
  basal_area <- with_year %>% 
  dplyr::group_by(species, Family, year) %>%
  basal_area(dbh = DBH) %>% 
  arrange(species, Family, year) %>% 
  dplyr::ungroup() %>% 
  tidyr::spread(year, basal_area, fill = 0)
basal_area
```

xxxcont.

* build integral function.
* map to all sites (`PlotName`).
* include all rows (not just a small subset).


# Reference

COUNT

https://forestgeo.si.edu/bci-abundance-all-tree-species-50-ha-plot-1982-2005-saplings-and-trees

https://forestgeo.si.edu/bci-abundance-all-tree-species-50-ha-plot-1982-2005-trees

BASAL AREA IN SQUARE METERS

https://forestgeo.si.edu/bci-basal-area-all-tree-species-50-ha-plot-1982-2005-saplings-and-trees

https://forestgeo.si.edu/bci-basal-area-all-tree-species-50-ha-plot-1982-2005-trees
