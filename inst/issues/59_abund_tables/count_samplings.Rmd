---
title: "Count saplings"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r}
library(dplyr)
library(fgeo)
```

> For example, if I want to see how many saplings there are per species, the
dbh range would be >=10mm and <100mm. A tree with multiple stems 120 and 20 will be counted, is this correct?

Data: Creating a dataset with one sapling (dbh >= 10 mm & dbh < 100 mm) and one tree (dbh >= 100 mm). The tree has two stems, of 20 mm and 120 mm; the sapling also has two stems, of 22 mm and 99 mm. 

```{r}
census <- data.frame(
    stringsAsFactors = FALSE,
    dbh = c(20, 120, 22, 99, NA),
    sp = c("sp1", "sp1", "sp2", "sp2", "sp2"),
    treeID = c("1", "1", "2", "2", "2"),
    stemID = c("1.1", "1.2", "2.1", "2.2", "2.3")
)
census
```

If we count distinct `treeID`s directly we get a wrong output. The problem is that the larger stem of the tree is dropped and the smaller one inluded -- making the tree appear like a sappling. We expect a total of only one saplig but we get two.

```{r}
# This preserves missing `dbh` (unless `na.rm = FALSE`)
saplings_bad <- census %>% 
  pick_dbh_min(10) %>% 
  pick_dbh_under(100)
saplings_bad

abundance_tree(saplings_bad)
```

The problem is clearer if we group by species. Note that sp1 should show zero saplings instead of 1.

```{r}
# Count unique instances of treeID by species
saplings_bad %>% 
  group_by(sp) %>% 
  abundance_tree()
```

The solution is to collapse the table to a single row per tree -- choosing the one of the stem with the greaterst `dbh`. For that we write a helper function.

```{r}
collapse_treeid <- function(.data) {
  .data %>% 
    group_by(.data$treeID) %>% 
    arrange(desc(.data$dbh)) %>% 
    filter(row_number() == 1) %>% 
    ungroup()
}
```

Now the output is as expected.

```{r}
saplings_good <- census %>% 
  collapse_treeid() %>% 
  filter(dbh >= 10) %>% 
  filter(dbh < 100)
saplings_good

abundance_tree(saplings_good)
```

---

> Then I want to count trees per species, i.e. >=100mm, this tree would also be counted by your current function, is this correct?

> If so, this will be wrong, since it will be counted twice. A tree with stems 120 and 20 is a tree, not a sapling, and should only be counted as a tree.

Again, we only get the correct result if we first collapse the dataset by choosing the largest stem of each tree.

```{r}
# This preserves missing `dbh` (unless `na.rm = FALSE`)
trees_bad <- census %>% 
  pick_dbh_min(100) %>% 
  group_by(sp) %>% 
  abundance_tree()
trees_bad

trees_good <- census %>% 
  collapse_treeid() %>% 
  pick_dbh_min(100) %>% 
  group_by(sp)
trees_good
abundance_tree(trees_good)
```

Now I can wrap this solution into a user-friendly funtions. 
