---
title: "Biomass"
subtitle: "Drafting the biomass function."
author: "Gabriel Arellano, Sean McMahon & Mauro Lepore"
date: "2017-09-06"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 6
vignette: >
  %\VignetteIndexEntry{Biomass}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
# hadley's settings
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,  # {mine}
  comment = "#>",
  collapse = TRUE,
  # cache = TRUE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)
```

## Overview

On Sept 6th, 2017, Gabriel, Sean and Mauro discussed what the biomass function of the __forestr__ package should look like. This vignette aims to developers and collaborators. Its goal is to record the main ideas we discussed so that we can share those ideas and build on them later.


## Setup

Loading some useful packages.

```{r pkgs}
library(tidyverse)
library(forestr)
```

Loading some useful data of stems from 1000 trees, selected randomly from Barro Colorado Island (data made
public in 2012, available at https://goo.gl/GmrwVq; see also ?forestr::bci12s7mini).

```{r stem}

# Making a tibble to get a nicer print method
stem0 <- as_tibble(bci12s7mini)
stem0
```

## Goal

The biomass module has two jobs: to calculate individuals' biomass and to summarize biomass within user-defined groups.

The second job we will address first. We choose this order because summarising biomass (or variable) is straight forward, but calculating each individual's biomass isn't. Biomass can be calculated in multiple ways, and users should be let to choose the way they think is best. So this vignette ends discussing the different ways to calculate biomass, which is the part for which discussion is more widely open.

## Last thing first: summarising biomass accross individuals by groups

Here we focus on summarising biomass accross individuals by groups, not in the way to calculate the biomass of each individual. So we'll just use the individuals' biomass directly from the `agb` variable of a stem dataset from Barro Colorado Island. Apart from `agb` we'll use a few more variables useful for calculating the by-groups summary.

```{r}
# getting biomass as it comes out of the box from the analytical tables
stem0$biomass <- stem0$agb

# focusing only on a few variables we care about
stem1 <- select(stem0, 
  treeID, stemID, quadrat, status, sp, biomass, 
)
stem1
```

Unfortunately, these data has no unique identifies. So let's create one so we one so we can simplify the dataset without loosing information.

```{r}
add_id <- function(x) {
  x$id <- paste0(x$treeID, "_", x$stemID)
  x
}
stem2 <- add_id(stem1)
stem2
```

`id` has the information from `treeID` and `stemID`; so we can safely remove `treeID` and `stemID`. We'll take the change to re-organize the variables to improve clarity.

```{r}
# Removing redundant variables; also placing id first, and biomass last
stem3 <- select(stem2, id, quadrat, status, sp, biomass)
stem3
```

A good way to summarize these data is to sum the biomass of all individuals in each species:

```{r}
by_sp <- group_by(stem3, sp)
by_sp <- dplyr::summarize(by_sp, biomass = sum(biomass, na.rm = TRUE))
```

Or we may want to sumarize by summing the abundance of each species in each quadrat:

```{r}
by_sp_quad <- group_by(stem3, sp, quadrat)
by_sp_quad <- summarize(by_sp_quad, biomass = sum(biomass, na.rm = TRUE))
```

Here are the first few species and quadrats which biomas is greater than cero:

```{r}
filter(by_sp_quad, biomass > 0)
```

In conclusion, we can easily write a function that groups the data by any number of variables and summarizes it by summing the biomass of individuals within each group. But how should we calculate the biomass of each individual?

## Calculate individuals' biomass

We think that the way to calculate the biomass of each individual should depend on how well the user knows the allometry functions for the species or site in the data.

The user provides:

* nothing: use table of species and E (from Chave 2012?).
A. a table of one allometric information per species, in the shape of a function or formula.
B. a table of one allometric information applicable to the entire site, in the shape of a function, or formula.
C. a table of one allometric information applicable to the entire dataset, in the shape of a function or formula.

We propose that `biomass()` should first try to use the information that the user provides, from more to less specific. This is, try first the informmation at the species-level, then at the site-level, and last at the dataset-level. If the user provides no information, then `biomass()` should use published information (e.g. the species by _E_ table in Chave 2012?), which we can store in __forestr__ and update whenever as needed.

Here is what the allometry table would look like for information at different levels:

```{r}
# Species level --------------------------------------------------------------

f1 <- function(x1){y1 ~ x1}
f2 <- function(x2){y2 ~ x2}
fn <- function(xn){yn ~ xn}

species_level <- tribble(
  ~species, ~f,
  "sp1"   , f1,
  "sp2"   , f2,
  "spn"   , fn
)

species_level



# Site level -----------------------------------------------------------------

f1 <- function(x1){y1 ~ x1}
f2 <- function(x2){y2 ~ x2}
fn <- function(xn){yn ~ xn}

site_level <- tribble(
  ~site  , ~f,
  "site1", f1,
  "site2", f2,
  "siten", fn
)

site_level



# Dataset level --------------------------------------------------------------

f <- function(x){y ~ x}

dataset_level <- tribble(
  ~dataset  , ~f,
  "dataset", f
  )

dataset_level
```

Whatever `biomass()` uses, it should inform the user of what functions it is using. That communication may be via conditionals such as messages or warnings and maybe a log file.
