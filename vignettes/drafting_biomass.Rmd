---
title: "Biomass"
subtitle: "Drafting the biomass function."
author: "Gabriel Arellano, Sean McMahon & Mauro Lepore"
date: "2017-09-06"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 6
vignette: >
  %\VignetteIndexEntry{Biomass}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE}
# hadley's settings
set.seed(1014)
options(digits = 3)

knitr::opts_chunk$set(
  echo = TRUE,  # {mine}
  comment = "#>",
  collapse = TRUE,
  # cache = TRUE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)
```



## Overview

On Sept 6th, 2017, Gabriel, Sean and Mauro discussed what the biomass function of the __forestr__ package should look like. This vignette aims to developers and collaborators. Its goal is to record the main ideas we discussed so that we can share those ideas and build on them later.

The white-board notes from that meeting is [here](.

## Setup

Loading some useful packages.

```{r pkgs}
library(tidyverse)
library(forestr)
```

Loading some useful data of stems from 1000 trees, selected randomly from Barro Colorado Island (data made
public in 2012, available at https://goo.gl/GmrwVq; see also ?forestr::bci12s7mini).

```{r stem}
# Making a tibble to get a nicer print method
stem0 <- as_tibble(bci12s7mini)
stem0
```



## Function names

> Generally, function names should be verbs, and arguments should be nouns. There are some exceptions: nouns are ok if the function computes a very well known noun (i.e. mean() is better than compute_mean()), or accessing some property of an object (i.e. coef() is better than get_coefficients()). A good sign that a noun might be a better choice is if youâ€™re using a very broad verb like __"get"__, __"compute"__, __"calculate"__, or __"determine"__. Use your best judgement and don't be afraid to rename a function if you figure out a better name later.

--http://r4ds.had.co.nz/functions.html#functions



## Goal

The biomass module has two jobs: to calculate individuals' biomass and to summarize biomass within user-defined groups.

The second job we will address first. We choose this order because summarising biomass (or variable) is straight forward, but calculating each individual's biomass isn't. Biomass can be calculated in multiple ways, and users should be let to choose the way they think is best. So this vignette ends discussing the different ways to calculate biomass, which is the part for which discussion is more widely open.



## Last thing first: summarising biomass accross individuals by groups

Here we focus on summarising biomass accross individuals by groups, not in the way to calculate the biomass of each individual. So we'll just use the individuals' biomass directly from the `agb` variable of a stem dataset from Barro Colorado Island. Apart from `agb` we'll use a few more variables useful for calculating the by-groups summary.

```{r}
# getting biomass as it comes out of the box from the analytical tables
stem0$biomass <- stem0$agb

# focusing only on a few variables we care about
stem1 <- select(stem0, 
  treeID, stemID, quadrat, status, sp, biomass, 
)
stem1
```

Unfortunately, these data has no unique identifies. So let's create one so we one so we can simplify the dataset without loosing information.

```{r}
add_id <- function(x) {
  x$id <- paste0(x$treeID, "_", x$stemID)
  x
}
stem2 <- add_id(stem1)
stem2
```

`id` has the information from `treeID` and `stemID`; so we can safely remove `treeID` and `stemID`. We'll take the change to re-organize the variables to improve clarity.

```{r}
# Removing redundant variables; also placing id first, and biomass last
stem3 <- select(stem2, id, quadrat, status, sp, biomass)
stem3
```

A good way to summarize these data is to sum the biomass of all individuals in each species:

```{r}
by_sp <- group_by(stem3, sp)
by_sp <- dplyr::summarize(by_sp, biomass = sum(biomass, na.rm = TRUE))
```

Or we may want to sumarize by summing the abundance of each species in each quadrat:

```{r}
by_sp_quad <- group_by(stem3, sp, quadrat)
by_sp_quad <- summarize(by_sp_quad, biomass = sum(biomass, na.rm = TRUE))
```

Here are the first few species and quadrats which biomas is greater than cero:

```{r}
filter(by_sp_quad, biomass > 0)
```

In conclusion, we can easily write a function that groups the data by any number of variables and summarizes it by summing the biomass of individuals within each group. Such a function can be written in a number of ways. We compared ways that used __base__ exclusively with those that used __dplyr__ and we found that the __dplyr__ approach is orders of magnitude faster. So here what the `biomass()` function may look like:

```
biomass <- function(census, groups) {
  # Translate grouping variables passed as strings to quoted expressions
  parsed_groupes <- lapply(groups, rlang::parse_quosure)
  
  # Group
  grouped <- dplyr::group_by(x, rlang::UQS(parsed_groupes))
  
  # Summarize within groups
  count <- dplyr::summarise(grouped, biomass = biomass_per_individual(.))
  
  # Make the output a common data structure
  as.data.frame(count)
}
```

But how should we calculate the biomass of each individual?



## Calculate individuals' biomass

We think that the way to calculate the biomass of each individual should depend on how well the user knows the allometry formulas of the species or site in the data.

`biomass_per_individual()` would need two inputs:

a. either census data and the name of the site, to calculate biomass with appropriate allometric formulas given by the `biomass_per_individual()` by default.
b. or census data and a custom allometry, to calculate biomass with allometric formulas given by the user.

This is what the definition of `biomass_per_individual() may look like:

```
biomass_per_individual <- function (x, site, custom_allometry = NULL) {
  # some code
}
```


### Flow

This is a draft of the simplified flow.

```
< User provides data? > 
|- NO: (Return Error 1)
YES: < User provides site? > 
     |- YES: (Use default Table A)
     NO: < User provides custom allometry? > 
         |- NO: (Return Error 2)
         YES: < Is allometry a table? >
              |- NO: < Is allometry a formula? > 
              |      |- NO: (Return Error 3)
              |      YES: (Make and use Table B)
              YES: < Table has name "species" >
                   |- YES: < Use custom Table C? >
                   NO: < Table has name "site"? >
                       |- NO: (Return Error 4)
                       YES: (Use Table D)



ERRORS

Error 1: Must provide data.
Error 2: Must provide either the site name or custom allometries.
Error 3: Custom allometry must be either a data frame or a formula.
Error 4: Custom table must contain names species or site.



TABLES

Table A (default): `site`, `formula`. I.e. formulas from Chave et al. 2014.
Table B (custom):  `site`, `formula`.
Table C (custom):  `species`, `formula`.
Table D (Custom):  `site`, `formula`.
```



## Allometry tables

Here is what the allometry table would look like for information at different levels:

```{r}
# Species level --------------------------------------------------------------

f1 <- function(x1){y1 ~ x1}
f2 <- function(x2){y2 ~ x2}
fn <- function(xn){yn ~ xn}

species_level <- tribble(
  ~species, ~f,
  "sp1"   , f1,
  "sp2"   , f2,
  "spn"   , fn
)

species_level



# Site level -----------------------------------------------------------------

f1 <- function(x1){y1 ~ x1}
f2 <- function(x2){y2 ~ x2}
fn <- function(xn){yn ~ xn}

site_level <- tribble(
  ~site  , ~f,
  "site1", f1,
  "site2", f2,
  "siten", fn
)

site_level



# Dataset level --------------------------------------------------------------

f <- function(x){y ~ x}

dataset_level <- tribble(
  ~dataset  , ~f,
  "dataset", f
  )

dataset_level
```

Whatever `biomass()` uses, it should inform the user of what functions it is using. That communication may be via conditionals such as messages or warnings and maybe a log file.
