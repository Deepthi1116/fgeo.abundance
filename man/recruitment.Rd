% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctfs-recruitment.R
\name{recruitment}
\alias{recruitment}
\alias{demography_df}
\title{Caculate recruitment for all and each species (as in the CTFS R package)}
\usage{
recruitment(census1, census2, mindbh = 10, alivecode = c("A", "AB", "AS"),
  split1 = NULL, split2 = NULL)

demography_df(.f, census1, census2, mindbh = 10, alivecode = c("A", "AB",
  "AS"), split1 = NULL)
}
\arguments{
\item{census1}{The R Analytical Table for a single census, either tree or
stem.}

\item{census2}{The matching R Analytical Table for a later census.}

\item{mindbh}{The minimum diameter above which the counts are done. Trees
smaller than `mindbh` are excluded. If `NULL`, all living trees are
included.}

\item{alivecode}{character, codes of the variable `status` that indicate the 
tree is alive. The default 'A' is the standard CTFS designation for living 
trees or stems}

\item{split1}{a vector of categories, one per individual}

\item{split2}{another vector of categories, one per individual}
}
\value{
(xxx ask documentation) A list with components:
\itemize{
\item \code{N2}:
\item \code{R}:
\item \code{rate}:
\item \code{lower}:
\item \code{upper}:
\item \code{time}:
\item \code{date1}:
\item \code{date2}:
}
}
\description{
\code{recruitment()} caculates recruitment accross the entire dataset or within
one or two groups and returns a list (as in
(http://ctfs.si.edu/Public/CTFSRPackage/). \code{demography_df()} takes any
demography function and performs the exact same calculation; it works accross
the entire dataset or within one group -- not within two groups. And instead
of a list it  returns a dataframe, which is easier to manipulate and view
(see examples).
}
\details{
For every individual of all species you must provide two complete datasets,
one per census, with variables \code{dbh}, \code{pom}, \code{status} and \code{date}. Any status
indicating a live tree can be submitted in the variable \code{alivecode}.
Survivors are all individuals alive in both censuses, with \code{status == A} in
the first census, and larger than the minimum dbh in the first census. The
total population in the second census includes all those alive, above the
minimum dbh, plus any other survivors. As in \code{\link[=mortality]{mortality()}}, individuals whose
status is NA in either census are deleted from all calculations.
}
\examples{
# Some data to play with
census1 <- forestr::bci12t6mini
census2 <- forestr::bci12t7mini

# A bit ackward to manipulate and view  -----------------------------------

recruitment(census1, census2)

# Trick to fit a few species on screen
each_spp <- recruitment.eachspp(census1, census2)
lapply(each_spp, head)

# Easier to manipulate and view -------------------------------------------

# `demography_df()` takes any function but only 1 or NULL splitting variables

split_null <- demography_df(.f = "recruitment", census1, census2)
split_null

split_quad <- demography_df(.f = "recruitment", census1, census2, 
  split1 = census1$quadrat)
head(split_quad, 10)

# Exploring recruitment for some interesting species

split_spp <- demography_df(.f = "recruitment", census1, census2, 
  split1 = census1$sp)
head(split_spp, 10)

sp_to_explore <- c("casesy", "ocotob", "soroaf")
long_format <- subset(split_spp, split1 \%in\% sp_to_explore)
long_format

library(tidyr)
wide_format <- tidyr::spread(long_format, key = split1, value = value)
wide_format
}
\seealso{
Other functions from http://ctfs.si.edu/Public/CTFSRPackage/: \code{\link{drp}},
  \code{\link{fill.dimension}}, \code{\link{find.climits}}
}
